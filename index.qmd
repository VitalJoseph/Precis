---
title: "Professional PrÃ©cis"
subtitle: "Author: (Vital Joseph II)"
---

# About the Author

Hello, my name is Vital Joseph, I am a junior here at Allegheny, majoring in computer science. I play on the football team here as well. I am looking forward to collaborating with everyone throughout the semester. I think this class is going to be very helpful for us all even though it might seem like a lot at the start, but I am ready to take on the challenge with you all.


# Week 1

## SE1

#### Summary

The contents of Preface went over the meaning of "software engineering" and what distinguished the term from programming, computer science, etc. Also how it compared to other terms that had "engineering" in it. Programming Over Time introduces the aspect of software engineering that deals with time. As a software engineer you want to program tools and software that stays valuable over a period of time.

#### Reflection

Reading through SE1 I got a better understanding of the term "software engineering" and what the goal of a software engineer's work should always encompass, which is longevity really. Through time, code and programs tend to become less sustainable and harder to use and understand. It is the software engineer's job to make software that is able to adapt and change over time, not just in the present.

#### Use-Case

To relate the readings to the chasten project, I believe our goal as a team is to make sure the tools we implement into chasten are not only bug free, but susceptible to a wide variety of patterns. The program uses expressions to find patterns in python program, so it would be more sustainable to recognize as many patterns as possible. 

## FB1

#### Summary

The contents of FB1 go into detail about software testing and how important it is to software. Examples of simple function testing are provided, as well as test execution, test generating, and test checking. An example of an automated test used in the read can be seen below.

```python
import bookutils

from Timer import Timer

with Timer() as t:
    for n in range(1, 10000):
        assertEquals(my_sqrt(n) * my_sqrt(n), n)
print(t.elapsed_time())

```
As you can see in the example above, `assertEquals` is used, which is a statement that checks if two values are equal. If true then nothing happens, but if false then an exception is raised, meaning a failed test. You can also see the Timer module is imported, allowing us to record the runtime of the test, which in this case is the output would be `0.0336528339976212`.

#### Reflection

Testing is a vital part of software engineering, testing helps identify bugs and locate bugs in programs that can cause crashes. Testing also helps is also a way to validate your code and shows that the user's needs are met. It can help miminimze risk later on in projects as well by pointing out bugs early on so that they dont come up later in the develpment process.

#### Use-Case

Making test is something that we will have to do in our develpment process of chasten. I think a group of people who are good at making test cases should be are so called bug finders. That way we could have multiple hands on different implementations instead of one person making their own test case for their own implementation. This would result in more bug-free code in my opinion.


# Week 2

## SE2

#### Summary

What is Software Engineering dives into the aspects of software engineering and the approach that google uses to have a sustainable codebase. The text goes into to detail how software engineering and programming are not the same. A lot of the difference is seen in the management of code over time, the scale and efficiency, and the decision making of the trade-offs and costs.

#### Reflection

Reading the contents of SE2, I understand software engineering in a different light. I always though of software engineering as just programming and never reealised there is much more to it. Programming is a vital part to software engineering but it certainly isnt all software engineering is. Now when I think of software engineering, I think of not only programming but modifcation, maintenece, testing, documentaion, etc. All areas that that are just as important as the development process of a program.

#### Use-Case

Through the develpoment process of chasten we need to make sure that we need stay on top of our maintnence an documentation for chasten to be sutainable. We are starting to get more comfortbale with adressing issues and assigning people to fix said issues as well as documenting any uncertaincies or problems we might come across. As long as we continue to improve as a collective we should be succsessful.


## FB2

#### Summary

This chapter of fuzzing book talks covers the coverage of code, which is the measurement of which parts of a program are actually executed during a test run. Code coverage tools can also show which parts of code have remained untested. Some types of code coverage mentioned in this chapter include line coverage, branh coverage, and statement coverage. Line covergage being a tool or metric that shows which lines of code were touched when running tests. Line coverage uses the `trace` method, which returns a list of lines executed in order. An example of line coverage can be seen below:
```python
>>> cov.coverage()
{('cgi_decode', 8),
 ('cgi_decode', 9),
 ('cgi_decode', 10),
 ('cgi_decode', 11),
 ('cgi_decode', 12),
 ('cgi_decode', 15),
 ('cgi_decode', 16),
 ('cgi_decode', 17),
 ('cgi_decode', 18),
 ('cgi_decode', 19),
 ('cgi_decode', 20),
 ('cgi_decode', 21),
 ('cgi_decode', 30),
 ('cgi_decode', 31),
 ('cgi_decode', 32)}
```
as you can see, the coverage method produces lines of code from the `trace` method that have executed at least once. Branch coverage is also important because it measure branches in code, which are the if statment and loops. Statement coverageis just a more fined tuned metric of line coverage because it measure each stement of code.


#### Reflection

Coverage is important in a program because it shows which parts of the code have been covered by tests and which parts remain untested. It isnt necessarily a test itself though and that was what I had to get my head wrapped around while reading. It simply helps with code testing my providing vital information that can be used to show that a test might need to be improved.

#### Use-Case

For the development of chasten, code coverage will be important for people working on test cases. It will show whether our test cases are efficient or not. Line and Branch coverage are probably going to be the most common and simple to implement. It might be tidious, but it will help ensure our test or testing the right code and help with sustainability.


# Week 3

## SE3

#### Summary

Reading the chapter of SE3, "How to Work Well on Teams", I found that the authors wanted to explain the importance of working with other people in software engineering and how to succeed in a engineering team. You have to evaluate yourself as a colleuge and make sure you have the basic foundation pillars you need to work with other people. Those pillars stem around humilty, trust, and respect.

#### Reflection

Reading this chapter I self reflected on myself as a member of a working team and asked myself questions about the three pillars of social interaction. 1. Am I afraid of people seeing that I am not familiar with ceartain technical skills? 2. Do I provide assistance when needed and do I seek assistance? Do I have trust that we will implement and fix the necessary tools for oour project? These questions I feel if answered truthfully will give insight on where you are at as a team player.

#### Use-Case

As we work with chasten, we have to make sure that we voice our uncertaincies or disapprovements to everyone. It is important that everyone is heard and feels like they have a voive in the matter. We are lso in a class where different people hast different levels of technical skills, It is our duty to assist in areas where we feel like we are technically advanced or at least have a firm idea of what to do and how to do it. The more we grow as a team, technically, the faster the development process will move along. The aim of this course is not meant for certain people with more expertise to carry the load, everyone should come out of the course with the same understanding of how our software works.

## FB3

#### Summary

In the "fuzzing" chapter of fuzzingbook, the main topic is fuzzing also known as random text generation. Which is the randomization of characters based on certain constraint into a string. In the chapter a simple fuzzer function is ran:
```python
def fuzzer(max_length: int = 100, char_start: int = 32, char_range: int = 32) -> str:
    """A string of up to `max_length` characters
       in the range [`char_start`, `char_start` + `char_range`)"""
    string_length = random.randrange(0, max_length + 1)
    out = ""
    for i in range(0, string_length):
        out += chr(random.randrange(char_start, char_start + char_range))
    return out
```
As you can see the `fuzzer` function takes in a max length which defaults to 100, this is how many charcaters are in the string. Then we have char start and range which is used in chr function towards the end of the function. This just gives a range of how many different ASCII codes are used iin the string. If all is correct then you should get a output looking like this.
```python
'!7#%"*#0=)$;%6*;>638:*>80"=</>(/*:-(2<4 !:5*6856&?""11<7+%<%7,4.8,*+&,,$,."'
```
A string full of random generated characters.

#### Reflection

Reading through the chapter I got a better understanding of the importance of fuzzing and how it played in testing mostly. Fuzzing can help identify bugs and vulnerabilities in code because it examplifies user-generated datac and not fixed inputs. This will show how well a program can handle diverse inputs.

#### Use-Case

While working on chasten it will be important to implement fuzzing testing technique to simulate user behaviour because the goal is for  chasten to be a user friendly software that students and faculty can use everyday.


# Week 4

## SE4

#### Summary

The chapter's "Knowledge Sharing" in SE main topic is organization. What is an organization in software engineering. Basically, a group of engineers and developers that come together to create and maintain software. Just like any team, there are challenges that you have to overcome to be successful in your project or end goal. Software orgranizations sometimes have problems creating cultures of learning where people are not afraid to share their lack of knowledge to gain knowledge from others. You have to give a little to get a little.

#### Reflection

Reading the chapter I reflected on what it takes to develop a environment where learning is the norm. You have to make sure that you, as someone that maybe has a lack of knowledge is a cerain area, communicate with others to and let it be known that you are seeking help. As well as the person that has a expetise in an area. For one, it is important that you branch out of area that your familiar with and challenge yourself as a software enginneer.  It is also important that you help others and share your knowledge if ypu are furhter along in an area or further along in solving an issue.

#### Use-Case

During the development process of chasten I think that as a class we are starting to get the ball running with just overall knowledge of the tools in chasten and how they work, but I think that some people are further along as others and it is important that they realize that and try and share their knowledge in instances. It is also important to work on diverse issues when choosing which ones you want to resolve, there are issue that work with source code as well as documentation.

## FB4

#### Summary

This chapter of `fuzzingbook` covers mutation analysis, which is another testing technique used to evaluate the effectiveness of a set of test cases. This testing technique measures the ability to detect changes or mutations in the source code of functions. The book uses the vocabulary "artificial faults" as changes to  function. Here is an example:
```python
def triangle_m1(a, b, c):
    if a == b:
        if b == c:
            return 'Equilateral'
        else:
            # return 'Isosceles'
            return None  # <-- injected fault
    else:
        if b == c:
            return "Isosceles"
        else:
            if a == c:
                return "Isosceles"
            else:
                return "Scalene"
```
As you can see a change has been made in the function. And a test case is used to detect any changes:

```python
with ExpectError():
    strong_oracle(triangle_m1)
```
This is the output:
```python
Traceback (most recent call last):
  File "/var/folders/xx/h9_h9csd3_9f81t89rrf1qr00000gn/T/ipykernel_15695/3191755624.py", line 2, in <module>
    strong_oracle(triangle_m1)
  File "/var/folders/xx/h9_h9csd3_9f81t89rrf1qr00000gn/T/ipykernel_15695/566939880.py", line 5, in strong_oracle
    assert fn(2, 2, 1) == 'Isosceles'
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError (expected)
```
The test case detected the mutation and produced and Error because it was expecting Itosceles instead of None.

#### Reflection
When looking at the strong_oracle and weak_oracle functions I was finding it hard to distinguish why one produced an error and one did not at first, but then I took a closer look at the weak_oracle function and saw that it used the did not equal operator which then skips the part of the function that was mutated. Thia made me realise the imnportance of having a strong test case.
```python
def weak_oracle(fn):
    assert fn(1, 1, 1) == 'Equilateral'

    assert fn(1, 2, 1) != 'Equilateral'
    assert fn(2, 2, 1) != 'Equilateral'
    assert fn(1, 2, 2) != 'Equilateral'

    assert fn(1, 2, 3) != 'Equilateral'
```


#### Use-Case

It is important in chasten that we implement new techniques that we learn throughout this course whether it be for test cases or implemeting source code. The more you can make software sustainable and bug-free the better. We should be aiming to learning new ways to do cerain tasks while reading through our books and then transferring that knowledge into our project.
