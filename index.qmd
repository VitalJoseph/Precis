---
title: "Professional PrÃ©cis"
subtitle: "Author: (Vital Joseph II)"
---

# About the Author

Hello, my name is Vital Joseph, I am a junior here at Allegheny, majoring in computer science. I play on the football team here as well. I am looking forward to collaborating with everyone throughout the semester. I think this class is going to be very helpful for us all even though it might seem like a lot at the start, but I am ready to take on the challenge with you all.


# Week 1

## SE1

#### Summary

The contents of Preface went over the meaning of "software engineering" and what distinguished the term from programming, computer science, etc. Also how it compared to other terms that had "engineering" in it. Programming Over Time introduces the aspect of software engineering that deals with time. As a software engineer you want to program tools and software that stays valuable over a period of time.

#### Reflection

Reading through SE1 I got a better understanding of the term "software engineering" and what the goal of a software engineer's work should always encompass, which is longevity really. Through time, code and programs tend to become less sustainable and harder to use and understand. It is the software engineer's job to make software that is able to adapt and change over time, not just in the present.

#### Use-Case

To relate the readings to the chasten project, I believe our goal as a team is to make sure the tools we implement into chasten are not only bug free, but susceptible to a wide variety of patterns. The program uses expressions to find patterns in python program, so it would be more sustainable to recognize as many patterns as possible. 

## FB1

#### Summary

The contents of FB1 go into detail about software testing and how important it is to software. Examples of simple function testing are provided, as well as test execution, test generating, and test checking. An example of an automated test used in the read can be seen below.

```python
import bookutils

from Timer import Timer

with Timer() as t:
    for n in range(1, 10000):
        assertEquals(my_sqrt(n) * my_sqrt(n), n)
print(t.elapsed_time())

```
As you can see in the example above, `assertEquals` is used, which is a statement that checks if two values are equal. If true then nothing happens, but if false then an exception is raised, meaning a failed test. You can also see the Timer module is imported, allowing us to record the runtime of the test, which in this case is the output would be `0.0336528339976212`.

#### Reflection

Testing is a vital part of software engineering, testing helps identify bugs and locate bugs in programs that can cause crashes. Testing also helps is also a way to validate your code and shows that the user's needs are met. It can help miminimze risk later on in projects as well by pointing out bugs early on so that they dont come up later in the develpment process.

#### Use-Case

Making test is something that we will have to do in our develpment process of chasten. I think a group of people who are good at making test cases should be are so called bug finders. That way we could have multiple hands on different implementations instead of one person making their own test case for their own implementation. This would result in more bug-free code in my opinion.


# Week 2

## SE2

#### Summary

What is Software Engineering dives into the aspects of software engineering and the approach that google uses to have a sustainable codebase. The text goes into to detail how software engineering and programming are not the same. A lot of the difference is seen in the management of code over time, the scale and efficiency, and the decision making of the trade-offs and costs.

#### Reflection

Reading the contents of SE2, I understand software engineering in a different light. I always though of software engineering as just programming and never reealised there is much more to it. Programming is a vital part to software engineering but it certainly isnt all software engineering is. Now when I think of software engineering, I think of not only programming but modifcation, maintenece, testing, documentaion, etc. All areas that that are just as important as the development process of a program.

#### Use-Case

Through the develpoment process of chasten we need to make sure that we need stay on top of our maintnence an documentation for chasten to be sutainable. We are starting to get more comfortbale with adressing issues and assigning people to fix said issues as well as documenting any uncertaincies or problems we might come across. As long as we continue to improve as a collective we should be succsessful.


## FB2

#### Summary

This chapter of fuzzing book talks covers the coverage of code, which is the measurement of which parts of a program are actually executed during a test run. Code coverage tools can also show which parts of code have remained untested. Some types of code coverage mentioned in this chapter include line coverage, branh coverage, and statement coverage. Line covergage being a tool or metric that shows which lines of code were touched when running tests. Line coverage uses the `trace` method, which returns a list of lines executed in order. An example of line coverage can be seen below:
```python
>>> cov.coverage()
{('cgi_decode', 8),
 ('cgi_decode', 9),
 ('cgi_decode', 10),
 ('cgi_decode', 11),
 ('cgi_decode', 12),
 ('cgi_decode', 15),
 ('cgi_decode', 16),
 ('cgi_decode', 17),
 ('cgi_decode', 18),
 ('cgi_decode', 19),
 ('cgi_decode', 20),
 ('cgi_decode', 21),
 ('cgi_decode', 30),
 ('cgi_decode', 31),
 ('cgi_decode', 32)}
```
as you can see, the coverage method produces lines of code from the `trace` method that have executed at least once. Branch coverage is also important because it measure branches in code, which are the if statment and loops. Statement coverageis just a more fined tuned metric of line coverage because it measure each stement of code.


#### Reflection

Coverage is important in a program because it shows which parts of the code have been covered by tests and which parts remain untested. It isnt necessarily a test itself though and that was what I had to get my head wrapped around while reading. It simply helps with code testing my providing vital information that can be used to show that a test might need to be improved.

#### Use-Case

For the development of chasten, code coverage will be important for people working on test cases. It will show whether our test cases are efficient or not. Line and Branch coverage are probably going to be the most common and simple to implement. It might be tidious, but it will help ensure our test or testing the right code and help with sustainability.


# Week 3

## SE3

#### Summary

Reading the chapter of SE3, "How to Work Well on Teams", I found that the authors wanted to explain the importance of working with other people in software engineering and how to succeed in a engineering team. You have to evaluate yourself as a colleuge and make sure you have the basic foundation pillars you need to work with other people. Those pillars stem around humilty, trust, and respect.

#### Reflection

Reading this chapter I self reflected on myself as a member of a working team and asked myself questions about the three pillars of social interaction. 1. Am I afraid of people seeing that I am not familiar with ceartain technical skills? 2. Do I provide assistance when needed and do I seek assistance? Do I have trust that we will implement and fix the necessary tools for oour project? These questions I feel if answered truthfully will give insight on where you are at as a team player.

#### Use-Case

As we work with chasten, we have to make sure that we voice our uncertaincies or disapprovements to everyone. It is important that everyone is heard and feels like they have a voive in the matter. We are lso in a class where different people hast different levels of technical skills, It is our duty to assist in areas where we feel like we are technically advanced or at least have a firm idea of what to do and how to do it. The more we grow as a team, technically, the faster the development process will move along. The aim of this course is not meant for certain people with more expertise to carry the load, everyone should come out of the course with the same understanding of how our software works.
